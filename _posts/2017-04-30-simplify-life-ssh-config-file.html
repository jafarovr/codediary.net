---
layout: post
status: publish
published: true
title: Simplify Your Life With an SSH Config File
author:
  display_name: codediary.net
  login: codediary
  email: info@codediary.net
  url: ''
author_login: codediary
author_email: info@codediary.net
wordpress_id: 201
wordpress_url: https://codediary.net/?p=201
date: '2017-04-30 16:20:26 +0100'
date_gmt: '2017-04-30 12:20:26 +0100'
categories:
- Security
- Linux
- Ubuntu
tags:
- SSH
---
<p>If you're anything like me, you probably log in and out of a half dozen remote servers (or these days, local virtual machines) on a daily basis. And if you're even <em>more</em> like me, you have trouble remembering all of the various usernames, remote addresses and command line options for things like specifying a non-standard connection port or forwarding local ports to the remote machine.</p>
<p><!--more--></p>
<h3 id="shell-aliases">Shell Aliases</h3>
<p>Let's say that you have a remote server named <code>dev.example.com</code>, which has <em>not</em> been set up with public/private keys for password-less logins. The username to the remote account is <em>fooey</em>, and to reduce the number of scripted login attempts, you've decided to change the default SSH port to <code>22000</code> from the normal default of <code>22</code>. This means that a typical command would look like:</p>
<pre>$ ssh fooey@dev.example.com -p 22000
password: *************</pre>
<p>Not too bad.</p>
<p>We can make things simpler and more secure by using a public/private key pair; I highly recommend using <a href="http://linux.die.net/man/1/ssh-copy-id">ssh-copy-id</a> for moving your public keys around. It will save you quite a few folder/file permission headaches.</p>
<pre><span class="nv">$ </span>ssh fooey@dev.example.com -p 22000
# Assuming your keys are properly setup&hellip;</pre>
<p>Now this doesn't seem all that bad. To cut down on the verbosity you could create a simple alias in your shell as well:</p>
<pre><span class="nv">$ </span><span class="nb">alias </span><span class="nv">dev</span><span class="o">=</span><span class="s1">'ssh fooey@dev.example.com -p 22000'
</span><span class="nv">$ </span>dev <span class="c"># To connect</span></pre>
<p>This works surprisingly well: Every new server you need to connect to, just add an alias to your <code>.bashrc</code> (or <code>.zshrc</code> if you hang with the cool kids), and voil&agrave;.</p>
<h3 id="sshconfig">~/.ssh/config</h3>
<p>However, there's a much more elegant and flexible solution to this problem. Enter the SSH config file:</p>
<pre># contents of $HOME/.ssh/config
Host dev
  HostName dev.example.com
  Port 22000
  User fooey</pre>
<p>This means that I can simply <code>$ ssh dev</code>, and the options will be read from the configuration file. Easy peasy. Let's see what else we can do with just a few simple configuration directives.</p>
<p>Personally, I use quite a few public/private keypairs for the various servers and services that I use, to ensure that in the event of having one of my keys compromised the damage is as restricted as possible. For example, I have a key that I use uniquely for my <a href="https://github.com/jperras">Github</a> account. Let's set it up so that that particular private key is used for all my github-related operations:</p>
<pre>Host dev
  HostName dev.example.com
  Port 22000
  User fooey
Host github.com
  IdentityFile ~/.ssh/github.key</pre>
<p>The use of <code>IdentityFile</code> allows me to specify exactly which private key I wish to use for authentification with the given host. You can, of course, simply specify this as a command line option for "normal" connections:</p>
<pre><span class="nv">$ </span>ssh -i ~/.ssh/blah.key username@host.com</pre>
<p>but the use of a config file with <code>IdentityFile</code> is <a href="https://git.wiki.kernel.org/index.php/GitTips#How_to_pass_ssh_options_in_git.3F">pretty much your only option</a> if you want to specify which identity to use for any git commands. This also opens up the very interesting concept of further segmenting your github keys on something like a per-project or per-organization basis:</p>
<pre>Host github-project1
  User git
  HostName github.com
  IdentityFile ~/.ssh/github.project1.key
Host github-org
  User git
  HostName github.com
  IdentityFile ~/.ssh/github.org.key
Host github.com
  User git
  IdentityFile ~/.ssh/github.key</pre>
<p>Which means that if I want to clone a repository using my organization credentials, I would use the following:</p>
<pre>$ git clone git@github-org:orgname/some_repository.git</pre>
<h3 id="going-further">Going further</h3>
<p>As any security-conscious developer would do, I set up firewalls on all of my servers and make them as restrictive as possible; in many cases, this means that the only ports that I leave open are <code>80/443</code> (for webservers), and port <code>22</code> for SSH (or whatever I might have remapped it to for obfuscation purposes). On the surface, this seems to prevent me from using things like a desktop MySQL GUI client, which expect port <code>3306</code> to be open and accessible on the remote server in question. The informed reader will note, however, that a simple local port forward can save you:</p>
<pre>$ ssh -f -N -L 9906:127.0.0.1:3306 coolio@database.example.com
# -f puts ssh in background
# -N makes it not execute a remote command</pre>
<p>This will forward all local port <code>9906</code> traffic to port <code>3306</code> on the remote <code>database.example.com</code> server, letting me point my desktop GUI to localhost (<code>127.0.0.1:9906</code>) and have it behave exactly as if I had exposed port<code>3306</code> on the remote server and connected directly to it.</p>
<p>Now I don't know about you, but remembering that sequence of flags and options for <a href="http://linux.die.net/man/1/ssh">SSH</a> can be a complete pain. Luckily, our config file can help alleviate that:</p>
<pre>Host tunnel
  HostName database.example.com
  IdentityFile ~/.ssh/coolio.example.key
  LocalForward 9906 127.0.0.1:3306
  User coolio</pre>
<p>Which means I can simply do:</p>
<pre>$ ssh -f -N tunnel</pre>
<p>And my local port forwarding will be enabled using all of the configuration directives I set up for the tunnel host. Slick.</p>
<p>Source:&nbsp;<a href="http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/" target="_blank" rel="noopener noreferrer">http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/</a></p>
